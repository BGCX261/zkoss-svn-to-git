package org.zerokode.designer.model;

import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.zerokode.designer.IDisposable;
import org.zerokode.designer.model.rules.engine.RulesEngine;
import org.zerokode.designer.model.rules.engine.exceptions.RulesException;
import org.zkoss.idom.Attribute;
import org.zkoss.idom.Document;
import org.zkoss.idom.Element;
import org.zkoss.idom.util.IDOMs;
import org.zkoss.lang.Classes;
import org.zkoss.zk.ui.AbstractComponent;
import org.zkoss.zk.ui.Component;
import org.zkoss.zk.ui.sys.ComponentCtrl;
import org.zkoss.zk.ui.metainfo.ZScript;

/**
 * Class that is used for converting
 * a specified Component model into a
 * ZUML definition file. 
 * @author chris.spiliotopoulos
 *
 */
public class ZUMLModel implements IDisposable
{
	/**
	 * The Document that represents a ZUML page 
	 */
	private Document _doc = null;
	
	/**
	 * A located Element within the Document 
	 */
	private Element _locatedElement = null;

	/**
	 * 1-argument constructor  
	 * @param cmpRoot The root component whose encompassed 
	 * model is to be converted.
	 */
	public ZUMLModel(Component cmpRoot)
	{
		// convert the model directly
		convertModelToZUML(cmpRoot);
	}

	/**
	 * Returns the ZUML iDOM Document object 
	 * that represents the given component model.
	 * @return The iDOM Document object
	 */
	public Document getZUMLDocument() { return _doc; }
	
	/**
	 * Returns a textual (ZUML) representation of 
	 * the converted model from the corresponding
	 * iDOM Document object.  
	 * @return A String that holds the ZUML
	 * representation
	 */
	public String getZUML() 
	{ 
		String sZUML = "";
		
		try
		{
			// convert the iDOM document into a string
			sZUML = IDOMs.toString(_doc);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		
		// return the ZUML string
		return sZUML; 
	}
	
	/**
	 * Parses the model and converts it into the
	 * ZUML corresponding representation, by 
	 * converting each model element in turn.
	 * @param cmpRoot
	 */
	protected void convertModelToZUML(Component component)
	{
		if (component == null)
			return;
		
		// create a new Document 
		if (_doc == null)
			_doc = new Document();

		try
		{
			// apply the Model-to-ZUML rules of the component
			// before creating its ZUML definition
			RulesEngine.applyRules(component, RulesEngine.MODEL_TO_ZUML_RULES);
		}
		catch (RulesException re)
		{
			// if a rules exception is thrown, 
			// do not convert the component to ZUML
			return;
		}
		
		// create the iDOM Element
		Element domElement = createElement((AbstractComponent) component);
		
		// add the Element to the Document
		addElementToDocument(domElement, component);
		
		// check if the component's children should be exported
		// to the ZUML representation
		if (! RulesEngine.getComponentFlag(component, RulesEngine.FLAG_EXPORT_CHILDREN_TO_ZUML))
			return;
		
		// get the component's children
		List listChildren = component.getChildren();

		if (listChildren.size() == 0)
			return;
		
		// loop through all the component's children
		Iterator iter = listChildren.iterator();
		while (iter.hasNext())
		{
			try
			{
				// get the next component in the list
				Component child = (Component) iter.next();
				
				if (child == null)
					continue;
				
				/*** RECURSION ***/
				convertModelToZUML(child);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}

	}
	
	/**
	 * Creates a DOM XUL representation of the
	 * given XulElement.
	 * @param cmp The XUL element to be converted
	 * @return The DOM XUL representation Element 
	 */
	private Element createElement(AbstractComponent cmp)
	{
		if (cmp == null)
			return null;
		
		Element domElement = null;
		
		try
		{
			// create a new iDOM Element using the component's name [in lowercase]
			domElement = new Element(StringUtils.lowerCase(ComponentFactory.getSimpleClassName(cmp)));
			
			// get the component's Id
			String sId = cmp.getUuid();
			
			// if the Id is auto-generated by the framework, 
			// it cannot be used for components that will be re-loaded
			// in a page. For this reason it might need to be fixed
			sId = ComponentFactory.fixAutoId(sId);
			
			domElement.setIdAttribute(sId, true);
			
			// create the element's attributes
			createAttributes(cmp, domElement);
			
			// create the element's event handlers
			createEventHandlers(cmp, domElement);
		}
		catch (Exception e)
		{

		}
		
		// return the iDOM Element
		return domElement;
	}
	
	/**
	 * Retrieves all the Component's attributes
	 * (get/set methods) and creates the corresponding
	 * attributes of the XUL element. 
	 * @param xul 
	 * @param domElement
	 */
	private void createAttributes(AbstractComponent cmp, 
								  Element domElement)
	{
		if ((cmp == null) || (domElement == null))
			return;

		// get the Component's class
		Class clazz = cmp.getClass();
		
		// get the property descriptors of the component's
		// implementation class
		PropertyDescriptor arrDescr[] = PropertyUtils.getPropertyDescriptors(clazz);

		// get the list of the component's attributes
		// that should not be visible in the ZUML definition
		String[] arrExcludedAttr = RulesEngine.getComponentAttributes(cmp, RulesEngine.ATTRIBUTES_EXCLUDE_FROM_ZUML);
				
		// loop through the properties array
		for (int i = 0; i < arrDescr.length; i++)
		{
			try
			{
				// get the next property descriptor
				PropertyDescriptor descr = arrDescr[i];
				
				// get the corresponding setter (Write) method
				Method setter = descr.getWriteMethod();
				Method getter = descr.getReadMethod();
							
				// if there is no setter method available, move on
				if (setter == null)
					continue;
				
				// get the corresponding XUL attribute name
				String sXULName = Classes.toAttributeName(setter.getName());
				
				// if the attribute name exists in the 
				// list of excluded attributes, move on 
				// to the next one
				if (! ArrayUtils.isEmpty(arrExcludedAttr))
				{
					if (ArrayUtils.contains(arrExcludedAttr, sXULName))
						continue;
				}
				
				// get the parameter type
				Class[] arrParamTypes = setter.getParameterTypes();
				
				// filter out setters with more than one parameters
				if (arrParamTypes.length > 1)
					continue;
				
				// filter out attributes that take Object arguments
				// (except from String)
				if (((arrParamTypes[0] != String.class) && 
					(arrParamTypes[0] != boolean.class) && 
					(arrParamTypes[0] != int.class) &&
					(arrParamTypes[0] != long.class))
				   )	
					{	
						continue;
					}
				
				Object value 			= null;
				String sDefaultValue 	= "";
				String sCurrentValue 	= "";
								
				// get the default 
				if (getter != null)
				{
					// create a new instance of the component (default)
					AbstractComponent template = (AbstractComponent) clazz.newInstance();
					
					try
					{
						// get the start-up value of the specific property 
						value = PropertyUtils.getProperty(template, Classes.toAttributeName(getter.getName()));
					}
					catch (Exception e)
					{
					}
					
					// clean up
					template.detach();
					template = null;
					
					if (value != null)
						sDefaultValue = String.valueOf(value);

					try
					{
						// get the current property value 
						value = PropertyUtils.getProperty(cmp, Classes.toAttributeName(getter.getName()));
					
						if (value != null)
							sCurrentValue = String.valueOf(value);
					}
					catch (Exception e)
					{
					}
				}
				
				// if the current property value is equal to the
				// default one, or is empty, then move on
				if ((sCurrentValue.equals(sDefaultValue)) || 
					StringUtils.isEmpty(sCurrentValue))
					continue;

				// if this is the "id" attribute, fix it first
				if (sXULName.equals("id"))
					sCurrentValue = ComponentFactory.fixAutoId(sCurrentValue);
				
				// create a new iDOM Attribute and attach it
				// to the specified Element
				Attribute domAttribute = new Attribute(sXULName, sCurrentValue); 
				domElement.setAttribute(domAttribute);
			}
			catch (Exception e)
			{
				e.printStackTrace();
				
				continue;
			}
		}
	}
	
	/**
	 * Creates all the event handle attributes
	 * registered with the specified component.
	 * @param xul 
	 * @param domElement
	 */
	protected void createEventHandlers(AbstractComponent cmp, 
			  						   Element domElement)
	{
		if (cmp == null)
			return;
		
		// get all the events that apply to this component
		String[] arrEvents = ComponentFactory.getComponentEvents(cmp.getClass());
		
		if (ArrayUtils.isEmpty(arrEvents))
			return;
		
		// iterate through the events array
		for (int i = 0; i < arrEvents.length; i++)
		{
			// get the next event's name
			String sEventName = StringUtils.trim(arrEvents[i]);
			
			// check if this event has a defined event handler (script)
			// [we don't care about event listeners, as we are after ZUML
			//  elements only - listeners are code elements]
			ZScript zScript = ((ComponentCtrl)cmp).getEventHandler(sEventName);
			
			if (zScript != null)
				continue;
			
			// add the event handler attribute to the element
			addEventHandler(domElement, sEventName, zScript.getRawContent());
		}
		
		// clean up
		for (int i = 0; i < arrEvents.length; i++)
			arrEvents[i] = null;
	}
	
	/**
	 * Adds the given Element to the current iDOM.
	 * @param domElement An XUL representation of a 
	 * model Component.
	 */
	private void addElementToDocument(Element domElement, 
									  Component component)
	{
		if ((domElement == null) || (_doc == null))
			return;
		
		if (_doc.getRootElement() == null)
			_doc.setRootElement(domElement);
		else
		{
			// get the parent iDOM Element using the parent
			// component's Id as the search criterion
			Element domParentElement = getElementById(ComponentFactory.fixAutoId(component.getParent().getUuid()));
			
			// append the new Element to the parent
			if (domParentElement != null)
				domParentElement.appendChild(domElement);
			else
				_doc.getRootElement().appendChild(domElement);
			
		}
		
	}
	
	/**
	 * Walks through the Document model
	 * and performs an element-by-element 
	 * search in using the specified matching
	 * attribute 
	 * @param sAttributeName The Attribute to search for
	 * @param tree The matching Attribute value
	 */
	protected Element locateElement(Element domElement,
									String sAttributeName,
								    String sAttributeValue)
	{
		if (_locatedElement != null)
			return _locatedElement;
		
		if (domElement == null)
			return null;

		// get the specified Attribute
		Attribute domAttribute = domElement.getAttributeItem(sAttributeName);
		
		if (domAttribute != null)
		{	
			// check if we have an Attribute value match
			if (domAttribute.getValue().equals(sAttributeValue))
			{
				_locatedElement = domElement;
				return domElement;
			}
		}
			
		// get the component's children
		List listChildren = domElement.getChildren();

		if ((listChildren == null) || (listChildren.size() == 0))
			return null;
		
		// loop through all the component's children
		Iterator iter = listChildren.iterator();
		while (iter.hasNext())
		{
			// get the next component in the list
			Element child = (Element) iter.next();
			
			if (child == null)
				continue;

			// parse the model of the child
			locateElement(child, sAttributeName, sAttributeValue);
		}
		
		return null;
	}
	
	/**
	 * Searches the Document for the specified 
	 * Element, by using its Id as the criterion.
	 * @return The matching Element
	 */
	private Element getElementById(String sId)
	{
		_locatedElement = null;
		
		if (StringUtils.isEmpty(sId))
			return null;
		
		// try to locate the Element
		locateElement(_doc.getRootElement(), "id", sId);
		
		return _locatedElement;
	}
	
	/**
	 * Returns the iDOM element representation
	 * of the specified visual component.
	 * @param element The component to look for 
	 * in the iDOM tree
	 * @return The corresponding iDOM element
	 */
	public Element getDOMElement(AbstractComponent element)
	{
		if (element == null)
			return null;
		
		// locate and return the Element representation
		return getElementById(element.getUuid());
	}
	
	/**
	 * Adds an event handler attribute to the
	 * iDOM representation of the given visual
	 * component.
	 * @param element The component instance
	 * @param sEventName The name of the event to 
	 * be handled
	 * @param sScript The script to be triggered
	 */
	public void addEventHandler(AbstractComponent element, 
							    String sEventName, 
							    String sScript)
	{
		if (element == null)
			return;
		
		try
		{
			// retrieve the iDOM Element by using the component;s Id 
			Element domElement = getDOMElement(element);
			
			if (domElement == null)
				return;
			
			// add the event handler attribute
			addEventHandler(domElement, sEventName, sScript);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	
	/**
	 * Adds an event handler attribute to the
	 * given iDOM Element
	 * @param element The iDOM element that represents
	 * a visual component
	 * @param sEventName The name of the event to 
	 * be handled
	 * @param sScript The script to be triggered
	 */
	protected void addEventHandler(Element domElement, 
							       String sEventName, 
							       String sScript)
	{
		if (domElement == null)
			return;
			
		// create a new Attribute that describes the event
		Attribute attrEventHandler = new Attribute(sEventName, sScript);
		
		// attach it to the element
		domElement.setAttributeNode(attrEventHandler);
	}

	/**
	 * Disposes the iDOM document
	 */
	protected void disposeDocument(Element domElement)
	{
		if (domElement == null)
			return;

		// get the component's children
		List listChildren = domElement.getChildren();

		if ((listChildren == null) || (listChildren.size() == 0))
			return;
		
		// loop through all the component's children
		Iterator iter = listChildren.iterator();
		while (iter.hasNext())
		{
			// get the next component in the list
			Element child = (Element) iter.next();
			
			if (child == null)
				continue;

			// parse the model of the child
			disposeDocument(child);
		}
		
		domElement = null;
	}
	
	/* (non-Javadoc)
	 * @see com.zk.designer.IDisposable#dispose()
	 */
	public void dispose()
	{
		// clean up
		if (_doc != null)
		{
			disposeDocument(_doc.getRootElement());
			_doc = null;
		}
	}
	
	/* (non-Javadoc)
	 * @see java.lang.Object#finalize()
	 */
	protected void finalize() throws Throwable
	{
		try
		{
			// clean up
			dispose();
		}
		catch (Exception e)	{ }
		finally
		{
			super.finalize();
		}
	}
}
